"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const memfs_1 = require("javascript-typescript-langserver/lib/memfs");
const util_1 = require("javascript-typescript-langserver/lib/util");
const fs = require("fs");
const path_1 = require("path");
class PatchedInMemoryFileSystem extends memfs_1.InMemoryFileSystem {
    constructor(path, logger) {
        super(path, logger);
        this.rootUri = util_1.path2uri(path);
        this.log = logger;
    }
    readFile(path) {
        const content = this.readFileIfExistsOverwrite(path);
        if (content === undefined) {
            // @ts-ignore
            // this.logger.info(`readFile ${path} requested by TypeScript but content not available`)
            const content = fs.readFileSync(path, 'utf8');
            this.add(util_1.path2uri(path), content);
            return content;
        }
        return content;
    }
    add(uri, content) {
        if (!uri.startsWith(this.rootUri) && uri.indexOf(path_1.join('node_modules', 'typescript')) === -1) {
            this.log.error('File ' + uri + ' out of root path');
        }
        else {
            super.add(uri, content);
        }
    }
    /**
     * @param path file path (both absolute or relative file paths are accepted)
     * @return file's content in the following order (overlay then cache).
     * If there is no such file, returns undefined
     */
    readFileIfExistsOverwrite(path) {
        const uri = util_1.path2uri(path);
        let content = this.overlay.get(uri);
        if (content !== undefined) {
            return content;
        }
        // TODO This assumes that the URI was a file:// URL.
        //      In reality it could be anything, and the first URI matching the path should be used.
        //      With the current Map, the search would be O(n), it would require a tree to get O(log(n))
        // @ts-ignore
        content = this.files.get(uri);
        if (content !== undefined) {
            return content;
        }
        return memfs_1.typeScriptLibraries.get(path);
    }
}
exports.PatchedInMemoryFileSystem = PatchedInMemoryFileSystem;
//# sourceMappingURL=memfs.js.map